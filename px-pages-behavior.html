<link rel="import" href="../px-mobile/px-mobile.html"/>
<script type="text/javascript">
  px.pages = {
    // add properties and methods on the element's prototype
    properties: {

      // declare properties for the element's public API
      title: {
        type: String,
        value: 'Predix Mobile Page'
      },

      //The default selected Page
      selected: {
        type: Number,
        reflectToAttribute: true,
        notify: true,
        observer: '_setCurrent',
        value: 0
      },

      //The current context of the Page.
      currentPage: {
        type: Object,
        value: {}
      },

      context: {
        type: Object,
        value: {}
      },

      //The list of pages
      pages: {
        type: Array
      },

      PageList: {
        type: Array
      },

      selectedIndex: {
        type: Number
      },
      //The pages routes
      routes: {
        type: Object,
        value: {}
      },

      //The in effect
      in: {
        type: String
      },

      //The out effect
      out: {
        type: String
      },

      //Loop pages once end is reached.
      loop: {
        type: Boolean,
        value: false
      }
    },

    emit: function (event, data) {
      this.logApi('emit:event', event, data);
      return px.mobile.dom('*body').trigger('page:' + event, data);
    },

    on: function (event, cb) {
      this.logApi('on:event', event);
      return px.mobile.dom('*body').on('page:' + event, cb);
    },

    created: function () {
      var logger = new px.mobile.Logger(this.tagName, {colors: {debug: 'color:blue'}});
      px.mobile.utils.addMixin(logger, this);

      this.logApi(this.id, 'created');

      this.PageMap = {};
      this.PageList = [];
    },

    ready: function () {
      this.logApi(this.id, 'ready');
      this._initpages();
      this.addClass('et-wrapper');
    },

    attached: function () {
      var _this = this;
      this.logApi('attached', this.id + ' - ' + this.selected);
      if (!this.id) {
        throw 'pages' + this.tagName + ' cannot be created without an id!';
      }
      this.debounce('selected', function() {
        _this.gotoIndex(_this.selected);
        console.warn('selected', _this.selected);
      }, 500);
    },

    _initpages: function () {
      var self = this;
      this.logApi('_initpages', this);
      var pages = Polymer.dom(this).querySelectorAll('px-page');
      var len = pages.length;
      for (var i = 0; i < len; i++) {
        this.logApi('page', pages[i]);
        self._addPage(pages[i]);
      }
    },

    //show Page
    showPage: function (index) {
      this.logApi('showPage', index);
      this.PageList[this.selected].toggleClass('et-page-current');
      this.selected = index;
      this.PageList[this.selected].child()[0].toggleClass('et-page-current');
    },

    //hide Page
    hidePage: function (index) {
      this.logApi('hidePage', index);
      this.toggleClass('hidden', true, this);
    },

    //update Page
    updatePage: function (page) {
      this.logApi('updatePage', page);
    },

    //Handle adding a Page to the map
    _addPage: function (Page) {
      this.emit('add', Page);

      //add the index to the el
      Page.attr('index', this.PageList.length.toString());

      //push to Page list
      this.PageList.push(Page);

      //add next class to element
      Page.addClass('et-page');
      Page.addClass('next');

      //add to Page map
      this.PageMap[Page.id] = Page;

      //Add to routeHandlers
      if (Page.route) {
        this.routes[Page.route] = Page.id;
      }

    },

    //Handle clearing all the 'current' classes.
    _clearCurrent: function () {
      this.logApi('_clearCurrent');
      var _pages = Polymer.dom(this).querySelectorAll('px-page');
      if (_pages) {
        _pages.forEach(function (Page) {
          Page.removeClass('current');
        });
      }
    }
  };


  px.pages._setCurrent = function (index, oldIndex) {
    this.logApi('_setCurrent', index);
    var prevPage = this.PageList[oldIndex];
    var currPage = this.PageList[index];

    this.emit('change', currPage);

    if (prevPage) {
      prevPage.removeClass('current');
      prevPage.removeClass('et-page-current');
      prevPage.addClass('previous');
    }

    if (currPage) {
      currPage.removeClass('next');
      currPage.addClass('current');
      currPage.addClass('et-page-current');
    }
  };


  px.pages.changePage = function (indexOrId) {
    this.emit('change', indexOrId);
    this.logApi('changePage', indexOrId);
    this._clearCurrent();
    if (this.PageList[indexOrId]) {
      this._setCurrent(indexOrId);
    } else if (this.PageMap[indexOrId]) {
      this._setCurrent(this.PageList.indexOf(this.PageMap[indexOrId]));
    }
  };


  // TODO: New IMplmenation
  px.pages.currentIndex = 0;
  px.pages.reset = function (reverse) {
    var _pages = this.PageList;
    var len = this.PageList.length;
    for (var i = 0; i < len; i++) {
      this.PageList[i].removeClass('current');
      if (reverse) {
        this.PageList[i].addClass('previous');
        this.PageList[i].removeClass('next');
      } else {
        this.PageList[i].addClass('next');
        this.PageList[i].removeClass('previous');
      }
    }
    this.PageList[this.selected].removeClass('next');
    if (reverse) {
      this.selected = this.PageList.length - 1;
    } else {
      this.selected = this.selected - (this.PageList.length - 1);
    }

    this.current();
  };

  px.pages.goto = function (indexOrId) {

    if (this.PageMap[indexOrId]) {
      return this.gotoPage(indexOrId);
    } else if(this.PageList[indexOrId]){
      return this.gotoIndex(indexOrId);
    }

  };

  /**
   * Goto a page
   */
  px.pages.gotoPage = function (id) {
    var index = 0;
    if (this.PageMap[id]) {
      index = this.PageList.indexOf(this.PageMap[id]);
    }
    this.selected = index;
    this.logApi('gotoPage', id, index);
  };

  /**
   * Goto a page by index
   * @param index
   */
  px.pages.gotoIndex = function (index) {
    this.logApi('gotoIndex', index);
    index = index || 0;
    if (this.PageList[index]) {
      this.PageList[index].removeClass('previous');
      this.PageList[index].removeClass('next');
      this.selected = index;
    } else {
      this.selected = 0;
    }
  };

  /**
   * The current page
   */
  px.pages.current = function () {
    this.logApi('current', this.selected);
    this.gotoIndex(this.selected);
  };

  /**
   * The next page
   */
  px.pages.next = function () {
    this.logApi('next', this.selected);
    if (this.selected >= this.PageList.length - 1) {
      if (this.loop) {
        this.reset();
      } else {
        this.current();
      }
    } else {
      this.gotoIndex(this.selected + 1);
    }
  };

  /**
   * The previous page
   */
  px.pages.prev = function () {
    if (this.selected <= 0) {
      if (this.loop) {
        this.reset(true);
      } else {
        this.current();
      }
    } else {
      this.gotoIndex(this.selected - 1);
    }
  };

  /**
   * Remove transition from page
   * @param index
   */
  px.pages.removeTransition = function (index) {
    var page = this.PageList[index];
    page.content.css('transition', 'none');
  };

  /**
   * Do a transition
   */
  px.pages.doTransition = function (index) {
    var page = this.PageList[index];
    var position = page.position();
    page
      .css('transition', 'all 400ms ease')
      .css('transform', 'translate3d(' + (-1 * (position.left)) + 'px, 0, 0)');
  };

  /**
   * Change the page
   * @param name
   */
  px.pages.change = function (name) {
    return this.goto(name);
  };

  /**
   * Load a page
   * @param url
   */
  px.pages.load = function (url) {

  };

  /**
   * Get the active page
   * @returns {*}
   */
  px.pages.getActivePage = function () {
    return this.PageList[this.selected];
  };

  //px.pages.currentPage = this.getActivePage();

  /**
   * Add a px-page from page object
   * @param obj
   */
  px.pages.addPage = function (obj) {

  };

  px.pages.getCurrentPage = function () {
    return this.PageList[this.selected];
  };

  px.pages.handleTrack = function (e) {
    var message = '';

    var currentIndex = this.selected;
    var containerWidth = this.offsetWidth;

    var containerLeft = 0;
    var distance = (currentIndex * containerWidth);

    var totaldist = distance + containerLeft;

    console.log(e);
    switch (e.detail.state) {
      case 'start':
        message = 'Tracking started!';
        break;

      //Finger is down and moving
      case 'track':

        var move = Math.min(e.detail.ddx, (currentIndex + 1) * distance);
        console.log('Tracking started!', move, e.detail.ddx, e.detail.dx, containerWidth);
        break;

      case 'end':
        message = 'Tracking ended!';
        break;
    }
    console.warn(message);
  };



</script>
