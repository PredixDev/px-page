<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selector.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/animations/fade-in-animation.html">
<link rel="import" href="../neon-animation/animations/fade-out-animation.html">
<link rel="import" href="px-page.html"/>
<link rel="import" href="px-page-styles.html"/>
<!--
The `px-pages` element handles managing a stack of `px-page` elements for a given view.

[![Build Status](https://travis-ci.org/PredixDev/px-page.svg?branch=master)](https://travis-ci.org/PredixDev/px-page)


This component is for use with child `px-page` elements, and is useful if your content exceeds
the viewport and want scrollable content.

For demo visit <a href="demo.html" target="_blank">here</a> or <a href="mobile-demo.html" target="_blank">mobile demo here</a>



### Usage

```
<link rel="import" href="../px-page/px-pages.html">
<div class="viewport">
	<px-pages id="pages" selected="0">
	  <px-page id="page1" main>One</px-page>
	  <px-page id="page2">Two</px-page>
	  <px-page id="page3">Three</px-page>
	  <px-page id="page4">four</px-page>
	</px-pages>
</div>
```





### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-pages` | Mixin applied to component | {}


@element px-pages
@blurb
@demo demo.html
@homepage index.html
-->
<dom-module id="px-pages">
	<style include="px-navbar-css"></style>
	<template>
		<style>
			:host {
				height: 100%;
				position: relative;
				-webkit-perspective: 1200px;
				-moz-perspective: 1200px;
				perspective: 1200px;
				display: block;
				overflow: hidden;
					min-height: 75vh;
			}


			:host .c-pages {

				position: relative;
				-webkit-transition: all 0.4s;
				transition: all 0.4s;
				-webkit-overflow-scrolling: touch;
				height: 100%;
				width: 100%;
				@apply(--px-pages);
			}

			:host ::content .c-page {
				width: 100%;
				height: 100%;
				position: absolute;
				top: 0;
				left: 0;
				visibility: hidden;
				overflow: hidden;
				-webkit-backface-visibility: hidden;
				-moz-backface-visibility: hidden;
				backface-visibility: hidden;
				-webkit-transform: translate3d(0, 0, 0);
				-moz-transform: translate3d(0, 0, 0);
				transform: translate3d(0, 0, 0);
				-webkit-transform-style: preserve-3d;
				-moz-transform-style: preserve-3d;
				transform-style: preserve-3d;
			}

			:host ::content .c-page:not(.current) {
				opacity: 0;
				visibility: hidden;
				/*
        -webkit-transition: all 0.2s ease;
        transition: all 0.2s ease;
        */
				@apply(--px-page);
			}
			:host ::content .current {
				opacity: 1;
				visibility: visible;
				/*
        transform: translate(0, 0);
        */
				@apply(--px-page-current);
			}

			:host ::content .next {
				/*
        transform: translate(50%, 0);
        */
				@apply(--px-page-next);
			}

			:host ::content .previous {
				/*transform: translate(-50%, 0);*/
				@apply(--px-page-previous);
			}
		</style>
		<div class="c-pages">
			<content id="pagesContent" select=".page, px-page, .px-page"></content>
		</div>
	</template>
</dom-module>
<script type="text/javascript">
	Polymer({
		is: 'px-pages',
		behaviors: [
			Polymer.IronSelectableBehavior, Polymer.IronResizableBehavior, Polymer.NeonAnimationRunnerBehavior
		],
		listeners: {
			'neon-animation-finish': '_onNeonAnimationFinish'
		},
		properties: {
			animationConfig: {
				type: Object,
				value: function () {
					return {
						'entry': {
							name: 'fade-in-animation',
							node: this
						},
						'exit': {
							name: 'fade-out-animation',
							node: this
						}
					}
				}
			},
			/**
       * The selected index
       */
			selected: {
				type: Number,
				reflectToAttribute: true,
				notify: true,
				observer: '_handleSelectedChange',
				value: 0
			},
			/**
       * The current active page object
       */
			selectedPage: {
				type: Object,
				notify: true
			},
			/**
       * The main page
       */
			mainPage: {
				type: Object
			},
			/**
       * The array of indexed pages
       */
			pages: {
				type: Array,
				value: function () {
					return [];
				}
			},
			/**
       * The class to set on element when selected.
       */
			selectedClass: {
				type: String,
				value: 'current'
			},
			/**
       * Update the URL with the current page #id attribute
       * @private
       */
			updateHash: {
				type: Boolean,
				value: false
			}
		},
		ready: function () {
			this._PageMap = {};
			this._PageList = [];
			this.selectable = 'c-page';
		},
		attached: function () {
			var _this = this;

			//  this.listen(this, 'track', 'handleTrack');
			this.async(function () {
				this._init();
				this.gotoIndex(this.selected);
			});
		},
		detached: function () {
			this._log('detached');
		},
		animate: function () {
			this.playAnimation();
		},
		_onNeonAnimationFinish: function () {
			console.log('animation done!');
		},
		_init: function () {
			var self = this;
			var pages = this.getPages();
			var len = this.getPages().length;
			for (var i = 0; i < len; i++) {
				self._addPage(pages[i]);
			}

			this.fire('px-pages-ready');
		},
		/**
     * Fires when the page is changed.
     * @event px-page-change
     */
		_handleSelectedChange: function (index, oldIndex) {
			var _this = this;
			var _pages = this.getPages();
			var prevPage = _pages[index - 1];
			var currPage = _pages[index];
			var nextPage = _pages[index + 1];
			this._clearCurrent();
			if (nextPage) {
				_this.toggleClass('next', true, nextPage);
				_this.toggleClass(_this.selectedClass, false, nextPage);
				_this.toggleClass('previous', false, nextPage);
			}
			if (prevPage) {
				_this.toggleClass(_this.selectedClass, false, prevPage);
				_this.toggleClass('next', false, prevPage);
				_this.toggleClass('previous', true, prevPage);
			}
			if (currPage) {
				currPage.nextPage = nextPage;
				currPage.prevPage = prevPage;
				_this.toggleClass('next', false, currPage);
				_this.toggleClass('previous', false, currPage);
				_this.toggleClass(_this.selectedClass, true, currPage);
				_this.selectedPage = currPage;
				_this.fire('px-page-change', currPage);
			}
			return currPage;
		},
		/**
     * Select a page by index or id
     * @param {String} value The value to select
     * @return {Object} Page element object
     */
		select: function (value) {
			return this.goto(value);
		},
		/**
     * Goto a page by index or id
     * @private
     * @return {Object} Page element object
     */
		goto: function (indexOrId) {
			var p = null;
			if (this._PageList[indexOrId]) {
				p = this._PageList[indexOrId];
				return this.gotoIndex(indexOrId);
			} else if (this._PageMap[indexOrId]) {
				p = this._PageMap[indexOrId];
				return this.gotoIndex(this.indexOf(p));
			} else {
				console.warn('Page', indexOrId, 'does not exist!');
				return false;
			}
		},
		/**
     * Handle adding a Page to the map and any neccessary properties for mapping.
     * @param Page
     * @private
     */
		_addPage: function (Page) {
			if (Page.main) {
				Page.toggleClass(this.selectedClass, true);
				this.mainPage = Page;
			}
			//add the index to the el
			Page.setAttribute('index', this._PageList.length.toString());
			//add next class to element
			this.toggleClass('et-page', true, Page);
			//Page.toggleClass('next'); add to Page map
			this._PageMap[Page.id] = Page;
			Page.container = this;
			//push to Page list
			this._PageList.push(Page);
			this.fire('px-page-add', Page);
		},
		/**
     * Resets all pages to there initial state.
     * @event px-page-reset
     */
		reset: function (selected) {
			var self = this;
			var _pages = this.getPages();
			var len = _pages.length;
			var p;
			this._clearCurrent();
			for (var i = 0; i < len; i++) {
				p = _pages[i];
				this.toggleClass(self.selectedClass, false, p);
				this.toggleClass('next', false, p);
				this.toggleClass('previous', false, p);
			}
			this.selected = selected || 0;
			this.toggleClass(self.selectedClass, true, _pages[this.selected]);
			this.fire('px-page-reset');
		},
		/**
     * Goto a page by index
     * @private
     * @return {Object} Page element object
     */
		gotoIndex: function (index) {
			var _this = this;
			var _pages = _this.getPages();
			var p = _pages[index];
			if (p) {
				this.selected = this.indexOf(p);
				return p;
			} else {
				return false;
			}
		},
		/**
     * Return the index of the page.
     * @param page
     * @return {Number} The page index
     */
		indexOf: function (page) {
			var i = this._pages.indexOf(page);
			if (i > -1) {
				return i;
			} else {
				return false;
			}
		},
		/**
     * Goto a page by #id
     * @private
     * @return {Object} Page element object
     */
		gotoPage: function (id) {
			var index = 0;
			var page = this._PageMap[id];
			if (page) {
				index = this.indexOf(page);
				if (index > -1) {
					this.selected = index;
					return page;
				} else {
					return false;
				}
			} else {
				return false;
			}
		},
		/**
     * Utility method for logging a warn to the console.
     * @private
     * @param type
     * @param message
     */
		_warn: function (type, message) {
			// if (this._debug) {   console.warn('PagesBehavior.' + type, message); }
		},
		/**
     * Utility method for logging to the console.
     * @private
     * @param type
     * @param message
     */
		_log: function (type, message) {
			// if (this._debug) {   console.log('PagesBehavior.' + type, message); }
		},
		/**
     * Clears the current page
     * @private
     */
		_clearCurrent: function () {
			var self = this;
			var _pages = this.getPages();
			var len = _pages.length;
			if (_pages) {
				for (var i = 0; i < len; i++) {
					self.toggleClass(self.selectedClass, false, _pages[i]);
				}
			}
		},
		/**
     * Get the current selected page
     * @return {Object} Page element object
     */
		getSelectedPage: function () {
			return this._pages[this.selected];
		},
		/**
     * Handle returning the previous page.
     * @return {Object} Page element object
     */
		getPrevious: function () {
			if (this.selected === 0) {
				return false;
			}
			return this._pages[this.selected - 1];
		},
		/**
     * Handle returning the next page.
     * @return {Object} Page element object
     */
		getNext: function () {
			if (this.selected === this._pages.length - 1) {
				return false;
			}
			return this._pages[this.selected + 1];
		},
		/**
     * Handle updating the location.hash
     * @private
     */
		_updateHash: function () {
			if (this.updateHash) {
				window.location.hash = this.getCurrentPage().id;
			}
		},
		/**
     * Handle setting the current page.
     * @private
     * @param index
     * @return {*}
     */
		current: function (index) {
			this.selected = index || this.selected;
			return this.gotoIndex(this.selected);
		},
		/**
     * Handle going to the next page in the index.
     * @private
     * @return {Number} Index
     */
		next: function () {
			if (this.selected >= this.getPages().length - 1) {
				if (this.loop) {
					this.reset();
				} else {
					this.current();
				}
				console.warn('next', 'end of page stack!');
				return;
			} else {
				this.selected++;
				//return this.gotoIndex(this.selected + 1);
			}
			return this.current();
		},
		/**
     * Handle going to the previous page in the index.
     * @private
     * @return {Number} The selected index
     */
		prev: function () {
			if (this.selected <= 0) {
				if (this.loop) {
					this.reset(true);
				} else {
					this.current();
				}
			} else {
				this.gotoIndex(this.selected - 1);
			}
		},
		/**
     * Selects the previous item. (alias for prev())
     * @return {Number} The selected index
     */
		selectPrevious: function () {
			return this.prev();
		},
		/**
     * Selects the next item. (alias for next())
     * @return {Number} The selected index
     */
		selectNext: function () {
			return this.next();
		},
		/**
     * Handles getting the current page in the stack.
     * @private
     * @return {Object} Page element object
     */
		getCurrent: function () {
			return this._pages[this.selected];
		},
		/**
     * Handles navigating back in the page stack.
     * @return {Number} The selected index
     */
		back: function () {
			return this.selected--;
		},
		/**
     * Handle setting the height of the current page to the height of the container.
     * @private

     _fixHeight: function () {
      var pHeight = this.offsetHeight;
      var pageHeight = this.selectedPage.offsetHeight;
      var pageContent = this.querySelector('.page-content');
      var contentHeight = pageContent.offsetHeight;
      pageContent.css('height', pageHeight + 'px');
      this._log('Parent', pHeight, 'Child', pageHeight, 'Content', contentHeight,
        pageContent);
      return pageContent;
    },   */
		/**
     * Handle returning the current content pages.
     * @returns {Array} Array of content pages.
     */
		getPages: function () {
			this._pages = this.queryAllEffectiveChildren('px-page');
			return this._pages;
		}
	});
</script>
